{
    "collab_server" : "",
    "contents" : "#Create 3d Universe Map\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\nfrom OpenGL.GLU import *\nfrom yt.mods import *\nfrom PIL import Image as im\nimport numpy as na\nimport h5py as h5\nimport sys, time\nfrom Image import *\nfrom _colormap_data import *\nimport random\nangle = 0\nspin = 0\nESCAPE = '\\033'\nGL_TEXTURE_RECTANGLE_ARB = 34037\n#sets up initial camera position\ncamx, camy, camz = (0.0, 0.0, 0.0)\nwindow = 0\n#loads the data and stores it in different variables\nfp = h5.File(\"enzo_tiny_cosmology/DD0029-star_colors.h5\", \"r\") #enzo_tiny_cosmology/DD0017-star_colors.h5\", \"r\")\nx_pos = fp[\"x_pos\"].value\ny_pos = fp[\"y_pos\"].value\nz_pos = fp[\"z_pos\"].value\nfluxa = fp[\"fluxa\"].value\nmass = fp[\"mass\"].value\n#finds the number of stars\nstarnum = x_pos.shape[0]\n#calculates min and max mass\nmaxmass = mass.max()\nmeanmass = mass.min()\n#finds the difference in flux between two filters (B and V)\nflux = fluxa[: ,2]-fluxa[:, 1]\n#calculates min and max flux\nmaxflux = flux.max()\nminflux = flux.min()\n\n#sets up a class with position, flux, radius, and color bin attributes\nclass particle:\n    def __init__(self):\n       \n        self.X= 0.0\n        self.Y= 0.0\n        self.Z= 0.0\n        self.fluxa= 0.0\n        self.rad= 0.0\n        self.bin= 0.0\n#creates the empty array \"stars\"        \nstars=[]\n\n#adds the class defined above to the array\nfor i in range(starnum):\n    particl=particle()\n    stars.append(particl)\n#colors= [(0.0, 0.0, 1.0), (0.0, 0.25, 1.0), (0.0, 0.5, 1.0), (0.0, 0.75, 1.0), (0.0, 1.0, 1.0), (0.0, 1.0, 0.75), (0.0, 1.0, 0.5), (0.0, 1.0, 0.25), (0.0, 1.0, 0.0), (0.25, 1.0, 0.0), (0.5, 1.0, 0.0), (0.75, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 0.75, 0.0), (1.0, 0.5, 0.0), (1.0, 0.25, 0.0), (1.0, 0.0, 0.0)]\n\n#method to load the texture\ndef LoadTextures():\n\tglobal  texture, zPlane\n        #opens the image\n\timage = open(\"texture2.bmp\")\n\tyPlane= (1.0, 0.0, 0.0, 0.0)\n        #defines the texture width and height as the image width and height\n\tix = image.size[0]\n\tiy = image.size[1]\n\timage = image.tostring(\"raw\", \"RGBX\", 0, -1)\n\t\n\t# Create Texture\n\ttexture = glGenTextures(1)\n\tglBindTexture(GL_TEXTURE_2D, texture)\n\t\n        #store texture \n\tglPixelStorei(GL_UNPACK_ALIGNMENT,1)\n\tglTexImage2D(GL_TEXTURE_2D, 0, 3, ix, iy, 0, GL_RGBA, GL_UNSIGNED_BYTE, image)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)\n        #glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n\t#glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST)\n        #glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)\n        #glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR)\n        #glTexGenfv(GL_S, GL_EYE_PLANE, yPlane)\n        #glTexGenfv(GL_T, GL_EYE_PLANE, yPlane) \n\n        #allows the texture to blend with the colors of the star\n\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)\n        #creates mipmaps that allow for zooming in close to the image\n\tgluBuild2DMipmaps(GL_TEXTURE_2D, 3, ix, iy, GL_RGBA, GL_UNSIGNED_BYTE, image)\n\n#defines the method for drawing a rectangle of the same dimensions as the texture\ndef DrawRect(origin, width, texture, texturewidth):\n\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glBegin(GL_QUADS)\n    glTexCoord2f(0, 0)\n    glVertex3f(origin[0]-width[0], origin[1] - width[1], origin[2])\n    glTexCoord2f(1, 0)\n    glVertex3f(origin[0]+width[0], origin[1] - width[1], origin[2])\n    glTexCoord2f(1, 1)\n    glVertex3f(origin[0]+width[0], origin[1] + width[1], origin[2])\n    glTexCoord2f(0, 1)\n    glVertex3f(origin[0]-width[0], origin[1] + width[1], origin[2])\n    glEnd()\n\n#defines the method for intializing the OpenGL window\ndef InitGL(Width, Height):\n    global quadratic, flux\n    \n    #loads textures\n    LoadTextures()\n    #allows for drawing of quadratics\n    quadratic = gluNewQuadric()\n    gluQuadricNormals(quadratic, GLU_SMOOTH)\n    gluQuadricTexture(quadratic, GL_TRUE)\n    #enables use of 2D textures\n    glEnable(GL_TEXTURE_2D)\n    #sets the background color of the window to black\n    glClearColor(0.0, 0.0, 0.0, 0.0)\n    glClearDepth(1.0)\n    #enables depth testing and draws all pixels no matter what depth (this is important so that stars located behind other stars are still drawn--otherwise only the stars in the front would contribute to the brightness)\n    glDepthFunc(GL_ALWAYS)\n    glEnable(GL_DEPTH_TEST)\n    glShadeModel(GL_SMOOTH)\n    #glEnable(GL_LIGHTING)\n    #glEnable(GL_LIGHT0)\n    #adds flux, color, and radius data to the array for each star\n    for i in range(starnum):\n        stars[i]\n        \n        #flux is set to a range of [0,255]\n        stars[i].fluxa= (((flux[i]-(-5.68360849461e-12))/((1.35207869063e-11)-(-5.68360849461e-12)))*255)\n\n        #print stars[i].fluxa\n        #flux values are sorted into an integer bin (these bins will later become the RGB values for each star)\n        stars[i].bin= na.searchsorted([0, 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60, 61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255], stars[i].fluxa, side= \"left\")\n        #print stars[i].bin\n        #adds the position data for each star, changing the ranges to be centered around the origin and pushing the image far enough back to be viewable\n        stars[i].X = (x_pos[i]*10)-5\n        stars[i].Y = (y_pos[i]*10)-5\n        stars[i].Z = (z_pos[i]*10)-20\n        \n        #sets the radius based on a scale of the mass (the most massive stars will have the biggest radii and vice versa)\n        stars[i].rad= ((mass[i]/meanmass)**0.5)/3000\n        \n    glMatrixMode(GL_PROJECTION)\n    glLoadIdentity()\n    #gluLookAt(0.0, 0.0, 15.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n    #sets the field of view\n    gluPerspective(45.0, float(Width)/float(Height), 0.1, 100.0)\n    glMatrixMode(GL_MODELVIEW)\n    #allows for blending\n    glEnable(GL_BLEND)\n    glBlendFunc(GL_ONE, GL_ONE)\n    #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n    #glLightfv(GL_LIGHT0, GL_AMBIENT, (0.5, 0.5, 0.5, 1.0))\n    #glLightfv(GL_LIGHT0, GL_DIFFUSE, (1.0, 1.0, 1.0, 1.0))\n    #glLightfv(GL_LIGHT0, GL_POSITION, (0.0, 0.0, 2.0, 1.0))\n\n#defines the method that is executed everytime the viewing window is resized\ndef ReSizeGLScene(Width, Height):\n    if Height == 0:\n        Height = 1\n    glViewport(0, 0,  Width, Height)\n    glMatrixMode(GL_PROJECTION)\n    glLoadIdentity()\n    #gluLookAt(0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n    gluPerspective(45.0, float(Width)/float(Height), 0.1, 100.0)\n    glMatrixMode(GL_MODELVIEW)\n\n#defines the method for drawing the actual scene\ndef DrawGLScene():\n    global quadratic, texture, rsphe,DrawRect, Width, Height, camx, camy, camz\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    glLoadIdentity()\n    \n    #sets up global rotation around the x and y axes\n    glRotated(angle, 0.0, 1.0, 0.0)\n    glRotated(spin, 1.0, 0.0, 0.0)\n    #sets up movement of the camera in the x, y, and z directions\n    glTranslatef(camx, camy, camz)\n    t0 = time.time()\n   \n    #draws each star as a rectangle with width given by stars.rad, position given by stars.X, stars.Y, and stars.Z, and color given by stars.bin\n    for i in range(starnum):\n       \n       #glBindTexture(GL_TEXTURE_2D, texture)\n       #glTexCoord2d(0.50, 0.50); glVertex3f(stars[i].X, stars[i].Y, stars[i].Z)\n       origin = (stars[i].X, stars[i].Y, stars[i].Z)\n       width = (stars[i].rad,stars[i].rad,stars[i].rad)\n       texturewidth = 128\n       \n       glColor4f(color_map_luts['RdBu'][0][stars[i].bin], color_map_luts['RdBu'][1][stars[i].bin], color_map_luts['RdBu'][2][stars[i].bin], 1.0)\n       DrawRect(origin, width, texture, texturewidth)\n       #gluSphere(quadratic, stars[i].rad, 32, 32)\n    t1 = time.time()\n    #print \"Redraw time = %g\" % (t1-t0)\n    \n    #swaps buffer so the drawn scene is displayed\n    glutSwapBuffers()\n\n#defines method for key presses\ndef keyPressed(key, x, y):\n    global window, angle, spin, camx,camy, camz\n    key = string.upper(key)\n    time.sleep(0.01)\n    #t0 = time.time()\n    #escape key terminates the program\n    if key == ESCAPE:\n        sys.exit()\n    #key specific to enzo_tiny_cosmology that automatically focuses on the biggest galaxy\n    elif key == 'G':\n        camz+=11.2\n        spin+=10\n        angle-=20\n        camy-=1.6\n        camx-=0.6\n        print \"G\"\n    #key specific to IsolatedGalaxy that automatically focuses on the galaxy\n    elif key == 'R':\n        camz+=14.89\n        print \"R\"\n    #zoom in\n    elif key == 'Z':\n        camz+=0.2\n        print \"Z\"\n    #zoom out\n    elif key == 'X':\n        camz-=0.2\n        print \"X\"\n    #rotates the camera view down\n    elif key == 'W':\n        camy-=0.2\n        print \"W\"\n    #rotates the camera view up\n    elif key == 'S':\n        camy+=0.2\n        print \"S\"\n    #rotates the camera view to the right \n    elif key == 'A':\n        camx+=0.2\n        print \"A\"\n    #rotates the camera view to the left\n    elif key == 'D':\n        camx-=0.2\n        print \"D\"\n    #translates the image to the left\n    elif key == 'J':\n        angle+=10\n        print \"J\"\n        glutPostRedisplay()\n    #translates the image to the right\n    elif key == 'L':\n        angle-=10\n        print \"L\"\n        glutPostRedisplay() \n    #translates the image up\n    elif key == 'I':\n        spin+=10\n        print \"I\"\n        glutPostRedisplay()\n    #translates the image down\n    elif key == 'K':\n        spin-=10\n        print \"K\"\n        glutPostRedisplay()\n    #takes a screenshot of the window and saves it as a PNG file\n    elif key == 'P':\n        glPixelStorei(GL_PACK_ALIGNMENT, 1)\n        data = glReadPixels(0, 0, 800, 600, GL_RGBA, GL_UNSIGNED_BYTE)\n        image = im.frombuffer(\"RGBA\", (800, 600), data, 'raw', \"RGBA\", 0, 1)       \n        image.show()\n        image.save('Pic*26.png', 'PNG')\n    #t1 = time.time()\n    #print \"Key pressed: time = %g\" % (t1-t0)\n\n#defines a method for mouse clicks\ndef mouse(button, state, clickx, clicky):\n    #defines what happens for a left click\n    if button == GLUT_LEFT_BUTTON:\n        if state == GLUT_DOWN:\n            #finds the window width and height in pixels\n            window_width = float(glutGet(GLUT_WINDOW_WIDTH))\n            window_height = float(glutGet(GLUT_WINDOW_HEIGHT))\n            #finds the position in pixels at the mouseclick\n            posit = [clickx, (window_height - clicky)]\n            #finds the position in codeunits at the mouseclick\n            mod = glGetDoublev(GL_MODELVIEW_MATRIX)\n            pro = glGetDoublev(GL_PROJECTION_MATRIX)\n            vie = glGetIntegerv(GL_VIEWPORT)\n            coord= gluUnProject(posit[0], posit[1], 0, model=mod, proj=pro, view=vie)\n \n            #glReadPixels(x, window_height-y-1, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE)\n            #glReadPixels(x, window_height-y-1, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT)\n            #glReadPixels(x, window_height-y-1, 1, 1, GL_STENCIL_INDEX, GL_UNSIGNED_INT)\n            \n            \n            print posit, window_width, window_height, coord\n            \n#the main method that calls of the other methods and makes the program run            \ndef main():\n    global window\n    glutInit(sys.argv)\n    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)\n    #sets the initial window size and position\n    glutInitWindowSize(800, 600)\n    glutInitWindowPosition(100,100)\n\n    window = glutCreateWindow(\"Image\")\n    glutDisplayFunc(DrawGLScene)\n    #glutFullScreen()\n    glutIdleFunc(DrawGLScene)\n    glutReshapeFunc(ReSizeGLScene)\n    glutKeyboardFunc(keyPressed)\n    glutMouseFunc(mouse)\n    #glutSpecialFunc(specialKeyPressed)\n    InitGL(640, 480)\n    glutMainLoop()\n\nmain()\n",
    "created" : 1528164797625.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1183732824",
    "id" : "ACBEDCE6",
    "lastKnownWriteTime" : 1528164820,
    "last_content_update" : 1528164820701,
    "path" : "~/Desktop/Projects/image3D.py",
    "project_path" : "image3D.py",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "python"
}